{"version":3,"sources":["lib/api.ts","lib/graph.ts","CircleOfSuck.ts","App.tsx","index.tsx"],"names":["axios","Axios","create","baseURL","configure","WeightedDiGraph","size","adjMatrix","this","_","map","Array","fill","n1","n2","weight","Error","n","compact","neighbor","getHamiltonian","graph","paths","getHamiltonianFrom","curr","currPath","flatMap","allFrom","nodes","length","includes","concat","shortestPath","minBy","useCircleOfSuck","year","conference","api","useAxios","url","data","useAPI","useState","loading","circleOfSuck","teams","result","setCircleOfSuck","useEffect","games","findCircleOfSuck","then","a","gameGraph","fromPairs","school","futureGames","each","conference_game","away_team","home_team","away_points","home_points","push","teamToIndex","i","losers","winner","loser","addEdge","home","away","hamiltonian","v","team1","arr","team2","from","to","isPlayed","NOW","Date","INITIAL_YEAR","getFullYear","getMonth","App","CircleOfSuck","isComplete","every","abbreviation","id","label","edges","width","dashes","options","height","physics","enabled","ReactDOM","render","document","getElementById"],"mappings":"iQAMMA,EAAQC,IAAMC,OAAO,CACzBC,QAAS,qEAGXC,YAAU,CAAEJ,UAOL,I,kBCbMK,EAAb,WAIE,WAAYC,GAAe,yBAH3BA,UAG0B,OAF1BC,eAE0B,EACxBC,KAAKF,KAAOA,EACZE,KAAKD,UAAYE,IAAEC,IAAIC,MAAML,IAAO,kBAAMG,IAAEG,KAAKD,MAAML,GAAO,SANlE,2CASE,SAAQO,EAAYC,EAAYC,GAC9B,GAAIF,GAAML,KAAKF,MAAQQ,GAAMN,KAAKF,KAChC,MAAM,IAAIU,MAAM,yBAElBR,KAAKD,UAAUM,GAAIC,GAAMC,IAb7B,qBAgBE,SAAQE,GACN,GAAIA,GAAKT,KAAKF,KACZ,MAAM,IAAIU,MAAM,yBAElB,OAAOP,IAAES,QAAQV,KAAKD,UAAUU,GAAGP,KAAI,SAACK,EAAQI,GAAT,OAC1B,OAAXJ,EAAkB,KAAO,CAAEA,SAAQI,oBArBzC,KAkCaC,EAAiB,SAACC,GAC7B,IAmBMC,EAjBqB,SAArBC,EAAsBC,EAAcC,GACxC,OAAOhB,IAAEiB,QAAQL,EAAMM,QAAQH,IAAO,YAA2B,IAAxBL,EAAuB,EAAvBA,SAAUJ,EAAa,EAAbA,OACjD,OAJe,IAIXI,GAA2BM,EAASG,MAAMC,SAAWR,EAAMf,KACtD,CAACmB,GAGNhB,IAAEqB,SAASL,EAASG,MAAOT,GACtB,GAGFI,EAAmBJ,EAAU,CAClCS,MAAOnB,IAAEsB,OAAON,EAASG,MAAOT,GAChCJ,OAAQU,EAASV,OAASA,OAKlBQ,CAnBK,EAmB0B,CAAEK,MAAO,CAnBnC,GAmBiDb,OAAQ,IACtEiB,EAAevB,IAAEwB,MAAMX,EAAO,UACpC,OAAKU,EAGEA,EAAaJ,MAFX,MC/CEM,EAAkB,SAACC,EAAcC,GAC5C,IAAMC,EFEc,SAACF,EAAcC,GACnC,MAAmBE,YAAS,CAC1BC,IAAI,SAAD,OAAWJ,EAAX,YAAmBC,EAAnB,WAEL,OAHA,oBAASI,KEHGC,CAAON,EAAMC,GACzB,EAAkCM,mBAA6B,CAC7DC,SAAS,EACTC,aAAc,KACdC,MAAO,OAHT,mBAAOC,EAAP,KAAeC,EAAf,KAsBA,OAhBAC,qBAAU,WACR,GAAKX,EAAL,CAIA,IAAQQ,EAAiBR,EAAjBQ,MAAOI,EAAUZ,EAAVY,MAEfC,EAAiBL,EAAOI,GAAOE,MAAK,SAACL,GACnCC,EAAgB,CACdJ,SAAS,EACTC,aAAcE,EACdD,gBAGH,CAACR,IAEGS,GASHI,EAAgB,uCAAG,WAAOL,EAAeI,GAAtB,uBAAAG,EAAA,yDAEjBC,EAAY5C,IAAE6C,UAAU7C,IAAEC,IAAImC,GAAO,kBAAgB,CAAhB,EAAGU,OAAsB,QAG9DC,EAAc,GAEpB/C,IAAEgD,KAAKR,GAAO,YAA0E,IAAvES,EAAsE,EAAtEA,gBAAiBC,EAAqD,EAArDA,UAAWC,EAA0C,EAA1CA,UAAWC,EAA+B,EAA/BA,YAAaC,EAAkB,EAAlBA,YAC9DJ,IAIe,OAAhBG,GAAwC,OAAhBC,EAC1BN,EAAYO,KAAK,CAACH,EAAWD,IACpBE,EAAcC,EACvBT,EAAUM,GAAWI,KAAKH,GAE1BP,EAAUO,GAAWG,KAAKJ,OAIxBK,EAAcvD,IAAE6C,UAAU7C,IAAEC,IAAImC,GAAO,WAAaoB,GAAb,MAAmB,CAAnB,EAAGV,OAAyBU,OAEnE5C,EAAQ,IAAIhB,EAAgBwC,EAAMhB,QACxCpB,IAAEgD,KAAKJ,GAAW,SAACa,EAAQC,GACzB1D,IAAEgD,KAAKS,GAAQ,SAACE,GACd/C,EAAMgD,QAAQL,EAAYG,GAASH,EAAYI,GAAQ,SAG3D3D,IAAEgD,KAAKD,GAAa,YAAmB,IAAD,mBAAhBc,EAAgB,KAAVC,EAAU,KACpClD,EAAMgD,QAAQL,EAAYM,GAAON,EAAYO,GAAO,GACpDlD,EAAMgD,QAAQL,EAAYO,GAAOP,EAAYM,GAAO,MAGhDE,EAAcpD,EAAeC,GAlCZ,0CAoCd,MApCc,iCAuChBZ,IAAEC,IAAI8D,EAAY9D,KAAI,SAAC+D,GAAD,OAAO5B,EAAM4B,OAAK,SAACC,EAAOT,EAAGU,GACxD,IAAMC,EAAQD,EAAIV,IAAMU,EAAI9C,OAAS,EAAI,EAAIoC,EAAI,GAEjD,MAAO,CACLY,KAAMH,EACNI,GAAIF,EACJG,SAAUtE,IAAEqB,SAASuB,EAAUqB,EAAMnB,QAASqB,EAAMrB,aA7CjC,4CAAH,wDCvChByB,EAAM,IAAIC,KACVC,EAAeF,EAAIG,eAAiBH,EAAII,WAAa,GAAK,EAAI,GAEvDC,EAAU,WAErB,MAAe3C,mBAASwC,GAAjB/C,EAAP,oBAEA,OACE,8BACE,sDAA4BA,EAA5B,KACA,kBAAC,EAAD,CAAcA,KAAMA,EAAMC,WAAW,UAKrCkD,EAA6D,SAAC,GAA0B,IAAxBnD,EAAuB,EAAvBA,KAAMC,EAAiB,EAAjBA,WAC1E,EAAyCF,EAAgBC,EAAMC,GAAvDO,EAAR,EAAQA,QAASC,EAAjB,EAAiBA,aAAcC,EAA/B,EAA+BA,MAE/B,GAAIF,EACF,OAAO,yCAGT,GAAqB,OAAjBC,EAEF,OAAO,0EAGT,IAAM2C,EAAa9E,IAAE+E,MAAM5C,EAAc,YAEzC,OACE,qCACI2C,GACA,0GAKF,mHAIEA,GACA,mKAKF,kBAAC,IAAD,CACElE,MAAO,CACLO,MAAOiB,EAAOnC,KAAI,gBAAG6C,EAAH,EAAGA,OAAQkC,EAAX,EAAWA,aAAX,MAA+B,CAC/CC,GAAInC,EACJoC,MAAM,GAAD,OAAKpC,EAAL,aAAgBkC,EAAhB,SAEPG,MAAOhD,EAAalC,KAAI,YAA6B,IAA1BmE,EAAyB,EAAzBA,KAAMC,EAAmB,EAAnBA,GAAIC,EAAe,EAAfA,SACnC,MAAO,CACLF,KAAMA,EAAKtB,OACXuB,GAAIA,EAAGvB,OACPsC,MAAOd,EAAW,EAAI,EACtBe,QAASf,OAIfgB,QAAS,CACPC,OAAQ,QACRC,QAAS,CACPC,SAAS,QCpErBC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,W","file":"static/js/main.56429bfd.chunk.js","sourcesContent":["import Axios from 'axios'\nimport useAxios, { configure } from 'axios-hooks'\n\nimport { Conference, Game, Team } from './types'\nimport { Maybe } from './typeutils'\n\nconst axios = Axios.create({\n  baseURL: 'https://raw.githubusercontent.com/brandonchinn178/circle-of-suck',\n})\n\nconfigure({ axios })\n\nexport type API = {\n  teams: Team[]\n  games: Game[]\n}\n\nexport const useAPI = (year: number, conference: Conference): Maybe<API> => {\n  const [{ data }] = useAxios({\n    url: `/data/${year}-${conference}.json`,\n  })\n  return data\n}\n","import _ from 'lodash'\n\nimport { Maybe } from './typeutils'\n\nexport class WeightedDiGraph {\n  size: number\n  adjMatrix: Maybe<number>[][]\n\n  constructor(size: number) {\n    this.size = size\n    this.adjMatrix = _.map(Array(size), () => _.fill(Array(size), null))\n  }\n\n  addEdge(n1: number, n2: number, weight: number) {\n    if (n1 >= this.size || n2 >= this.size) {\n      throw new Error('Vertex does not exist')\n    }\n    this.adjMatrix[n1][n2] = weight\n  }\n\n  allFrom(n: number): { weight: number; neighbor: number }[] {\n    if (n >= this.size) {\n      throw new Error('Vertex does not exist')\n    }\n    return _.compact(this.adjMatrix[n].map((weight, neighbor) =>\n      weight === null ? null : { weight, neighbor }\n    ))\n  }\n}\n\ntype Path = {\n  nodes: number[]\n  weight: number\n}\n\n/**\n * Get the shortest hamiltonian path of the given graph.\n */\nexport const getHamiltonian = (graph: WeightedDiGraph): Maybe<number[]> => {\n  const START_NODE = 0\n\n  const getHamiltonianFrom = (curr: number, currPath: Path): Path[] => {\n    return _.flatMap(graph.allFrom(curr), ({ neighbor, weight }) => {\n      if (neighbor === START_NODE && currPath.nodes.length === graph.size) {\n        return [currPath]\n      }\n\n      if (_.includes(currPath.nodes, neighbor)) {\n        return []\n      }\n\n      return getHamiltonianFrom(neighbor, {\n        nodes: _.concat(currPath.nodes, neighbor),\n        weight: currPath.weight + weight,\n      })\n    })\n  }\n\n  const paths = getHamiltonianFrom(START_NODE, { nodes: [START_NODE], weight: 0 })\n  const shortestPath = _.minBy(paths, 'weight')\n  if (!shortestPath) {\n    return null\n  }\n  return shortestPath.nodes\n}\n","import _ from 'lodash'\nimport { useEffect, useState } from 'react'\n\nimport { useAPI } from './lib/api'\nimport { getHamiltonian, WeightedDiGraph } from './lib/graph'\nimport { Conference, Game, Team } from './lib/types'\nimport { Maybe } from './lib/typeutils'\n\ntype CircleOfSuckResult = {\n  loading: boolean\n  circleOfSuck: Maybe<CircleOfSuckEdge[]>\n  teams: Maybe<Team[]>\n}\n\nexport const useCircleOfSuck = (year: number, conference: Conference): CircleOfSuckResult => {\n  const api = useAPI(year, conference)\n  const [result, setCircleOfSuck] = useState<CircleOfSuckResult>({\n    loading: true,\n    circleOfSuck: null,\n    teams: null,\n  })\n\n  useEffect(() => {\n    if (!api) {\n      return\n    }\n\n    const { teams, games } = api\n\n    findCircleOfSuck(teams, games).then((result) => {\n      setCircleOfSuck({\n        loading: false,\n        circleOfSuck: result,\n        teams,\n      })\n    })\n  }, [api])\n\n  return result\n}\n\ntype CircleOfSuckEdge = {\n  from: Team\n  to: Team\n  isPlayed: boolean // has this game already been played?\n}\n\nconst findCircleOfSuck = async (teams: Team[], games: Game[]): Promise<Maybe<CircleOfSuckEdge[]>> => {\n  // maps winner team -> loser team\n  const gameGraph = _.fromPairs(_.map(teams, ({ school }) => [school, [] as string[]]))\n\n  // contains all future games, as [home_team, away_team] pairs\n  const futureGames = [] as [string, string][]\n\n  _.each(games, ({ conference_game, away_team, home_team, away_points, home_points }) => {\n    if (!conference_game) {\n      return\n    }\n\n    if (away_points === null || home_points === null) {\n      futureGames.push([home_team, away_team])\n    } else if (away_points > home_points) {\n      gameGraph[away_team].push(home_team)\n    } else {\n      gameGraph[home_team].push(away_team)\n    }\n  })\n\n  const teamToIndex = _.fromPairs(_.map(teams, ({ school }, i) => [school, i]))\n\n  const graph = new WeightedDiGraph(teams.length)\n  _.each(gameGraph, (losers, winner) => {\n    _.each(losers, (loser) => {\n      graph.addEdge(teamToIndex[winner], teamToIndex[loser], 0)\n    })\n  })\n  _.each(futureGames, ([home, away]) => {\n    graph.addEdge(teamToIndex[home], teamToIndex[away], 1)\n    graph.addEdge(teamToIndex[away], teamToIndex[home], 1)\n  })\n\n  const hamiltonian = getHamiltonian(graph)\n  if (!hamiltonian) {\n    return null\n  }\n\n  return _.map(hamiltonian.map((v) => teams[v]), (team1, i, arr) => {\n    const team2 = arr[i === arr.length - 1 ? 0 : i + 1]\n\n    return {\n      from: team1,\n      to: team2,\n      isPlayed: _.includes(gameGraph[team1.school], team2.school),\n    }\n  })\n}\n","import _ from 'lodash'\nimport React, { FC, useState } from 'react'\nimport Graph from 'react-graph-vis'\n\nimport { Conference } from './lib/types'\nimport { useCircleOfSuck } from './CircleOfSuck'\n\n// year should initially be the year of the last fall season\nconst NOW = new Date()\nconst INITIAL_YEAR = NOW.getFullYear() + (NOW.getMonth() < 6 ? -1 : 0)\n\nexport const App: FC = () => {\n  // TODO: make inputtable by user\n  const [year] = useState(INITIAL_YEAR)\n\n  return (\n    <main>\n      <h1>PAC-12 Circle of Suck ({year})</h1>\n      <CircleOfSuck year={year} conference=\"PAC\" />\n    </main>\n  )\n}\n\nconst CircleOfSuck: FC<{ year: number; conference: Conference }> = ({ year, conference }) => {\n  const { loading, circleOfSuck, teams } = useCircleOfSuck(year, conference)\n\n  if (loading) {\n    return <p>Loading...</p>\n  }\n\n  if (circleOfSuck === null) {\n    // TODO: show some other interesting graph\n    return <p>No possible circle of suck for this season.</p>\n  }\n\n  const isComplete = _.every(circleOfSuck, 'isPlayed')\n\n  return (\n    <>\n      {!isComplete && (\n        <p>\n          No complete circle of suck was found. Displaying a possible circle of\n          suck.\n        </p>\n      )}\n      <p>\n        An arrow from school A to school B represents a game where school A\n        beats school B.\n      </p>\n      {!isComplete && (\n        <p>\n          A dashed arrow from school A to school B represent a future game\n          that could complete the circle of suck, if school A beats school B.\n        </p>\n      )}\n      <Graph\n        graph={{\n          nodes: teams!.map(({ school, abbreviation }) => ({\n            id: school,\n            label: `${school} (${abbreviation})`,\n          })),\n          edges: circleOfSuck.map(({ from, to, isPlayed }) => {\n            return {\n              from: from.school,\n              to: to.school,\n              width: isPlayed ? 2 : 1,\n              dashes: !isPlayed,\n            }\n          })\n        }}\n        options={{\n          height: '500px',\n          physics: {\n            enabled: false,\n          },\n        }}\n      />\n    </>\n  )\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\n\nimport { App } from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}